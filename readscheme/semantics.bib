@book{Dybvig1996a,
  title = "{The Scheme Programmming Language}",
  author = "Dybvig, R.~Kent",
  year = 1996,
  edition = {Second Edition},
  publisher = {Prentice Hall},
  url = {https://www.scheme.com/tspl2/}
}

@inproceedings{MatthewsFindler2005a,
  title = "{An Operational Semantics for R5RS Scheme}",
  author = "Matthews, Jacob and Findler, Robert Bruce",
  booktitle = {Proceedings of the Sixth Workshop on Scheme and Functional Programming (Scheme 2005)},
  year = 2005,
  month = sep,
  pages = {41--54},
  url = {http://www.schemeworkshop.org/2005/04-matthews/04-matthews.pdf}
}

@inproceedings{Danvy2008a,
  title = "{Towards Compatible and Interderivable Semantic Specifications for the Scheme Programming Language, Part I: Denotational Semantics, Natural Semantics, and Abstract Machines}",
  author = "Danvy, Olivier",
  booktitle = {Proceedings of the 2008 Workshop on Scheme and Functional Programming (Scheme 2008)},
  year = 2008,
  month = sep,
  url = {http://www.schemeworkshop.org/2008/paper3.pdf}
}

@inproceedings{BiernackaDanvy2008a,
  title = "{Towards Compatible and Interderivable Semantic Specifications for the Scheme Programming Language, Part II: Reduction Semantics and Abstract Machines}",
  author = "Biernacka, Małgorzata and Danvy, Olivier",
  booktitle = {Proceedings of the 2008 Workshop on Scheme and Functional Programming (Scheme 2008)},
  year = 2008,
  month = sep,
  url = {http://www.schemeworkshop.org/2008/paper4.pdf}
}

@inproceedings{MeredithHillsRosu2007a,
  title = "{An Executable Rewriting Logic Semantics of K-Scheme}",
  author = "Meredith, Patrick and Hills, Mark and Rosu, Grigore",
  booktitle = {Proceedings of the 2007 Workshop on Scheme and Functional Programming (Scheme 2007)},
  year = 2007,
  month = sep,
  url = {http://www.schemeworkshop.org/2007/procPaper9.pdf}
}

@inproceedings{10.1145/155090.155103,
  title = "{First-class Data-type Representations in SCHEMEXEROX}",
  author = "Adams, Norman and Curtis, Pavel and Spreitzer, Mike",
  booktitle = {Proceedings of the ACM SIGPLAN 1993 Conference on Programming Language Design and Implementation (PLDI '93)},
  year = 1993,
  month = aug,
  pages = {139--146},
  publisher = {Association for Computing Machinery},
  url = {https://dl.acm.org/doi/10.1145/155090.155103},
  doi = {10.1145/155090.155103}
}

@article{10.1145/173262.155103,
  title = "{First-class Data-type Representations in SCHEMEXEROX}",
  author = "Adams, Norman and Curtis, Pavel and Spreitzer, Mike",
  journal = {ACM SIGPLAN Notices},
  volume = 28,
  number = 6,
  year = 1993,
  month = jun,
  pages = {139--146},
  publisher = {Association for Computing Machinery},
  url = {https://dl.acm.org/doi/10.1145/173262.155103},
  doi = {10.1145/173262.155103},
}

@inproceedings{10.1145/62678.62686,
  title = "{λ-v-CS: An Extended λ-Calculus for Scheme}",
  author = "Felleisen, Matthias",
  booktitle = {Proceedings of the 1988 ACM Conference on LISP and Functional Programming (LFP '88)},
  year = 1988,
  month = jul,
  pages = {72--85},
  publisher = {Association for Computing Machinery},
  url = {https://dl.acm.org/doi/10.1145/62678.62686},
  doi = {10.1145/62678.62686}
}

@phdthesis{Felleisen1987a,
  title = "{The calculi of lambda-v-CS conversion: A syntactic theory of control and state in imperative higher-order programming languages}",
  author = "Felleisen, Matthias",
  school = {Indiana University},
  year = 1987,
  month = aug,
  url = {https://www.proquest.com/docview/303475687}
}

@phdthesis{Mason1986a,
  title = "{The Semantics of Destructive Lisp}",
  author = "Mason, Ian Alistair",
  school = {Stanford University},
  year = 1986,
  url = {https://searchworks.stanford.edu/view/1241285}
}

@phdthesis{Talcott1985a,
  title = "{The essence of Rum: A theory of the intensional and extensional aspects of Lisp-type computation}",
  author = "Talcott, Carolyn L.",
  school = {Stanford University},
  year = 1985,
  url = {https://searchworks.stanford.edu/view/1190063}
}

@techreport{STAN-CS-89-1288,
  title = "{Programming and Proving with Function and Control Abstractions}",
  author = "Talcott, Carolyn L.",
  institution = {Stanford University},
  year = 1989,
  month = oct,
  number = {STAN-CS-89-1288},
  url = {https://searchworks.stanford.edu/view/4620407},
  note = "Labeled as CS-TR-89-1288 on readscheme.org"
}

@article{10.1016/0304-3975(92)90014-7,
  title = "{The revised report on the syntactic theories of sequential control and state}",
  author = "Felleisen, Matthias and Hieb, Robert",
  journal = {Theoretical Computer Science},
  volume = 103,
  number = 2,
  year = 1992,
  month = sep,
  pages = {235--271},
  doi = {10.1016/0304-3975(92)90014-7},
  url = {https://www.sciencedirect.com/science/article/pii/0304397592900147},
  note = "Seems a version of Matthias Felleisen and Robert Hieb. ``The Revised Report on the Syntactic Theories of Sequential Control and State''. Rice University. June 1989. referenced at readscheme.org."
}

@techreport{IUCS-TR348,
  title = "{Characterizing the Paralation Model using Dynamic Assignment}",
  author = "Freeman, Eric T. and Friedman, Daniel P.",
  institution = {Indiana University},
  year = 1992,
  month = mar,
  number = {TR348},
  url = {https://legacy.cs.indiana.edu/ftp/techreports/TR348.pdf}
}

@techreport{IUCS-TR350,
  title = "{First-Class Extents}",
  author = "Lee, Shinn-Der and Friedman, Daniel P.",
  institution = {Indiana University},
  year = 1992,
  month = aug,
  number = {TR350},
  url = {https://legacy.cs.indiana.edu/ftp/techreports/TR350.pdf},
  note = "Originally published on March 1992 and revised on August 1992."
}

@techreport{IUCS-TR365,
  title = "{Quasi-Static Scoping: Sharing Variable Bindings Across Multiple Lexical Scopes}",
  author = "Lee, Shinn-Der and Friedman, Daniel P.",
  institution = {Indiana University},
  year = 1992,
  month = oct,
  number = {TR350},
  url = {https://legacy.cs.indiana.edu/ftp/techreports/TR365.pdf}
}

@article{10.1145/1039991.1039992,
  title = "{An Operational Semantics for Scheme}",
  author = "Ramsdell, John D.",
  journal = {ACM SIGPLAN Lisp Pointers},
  volume = {V},
  number = 2,
  pages = {6--10},
  year = 1992,
  month = apr,
  publisher = {Association for Computing Machinery},
  doi = {10.1145/1039991.1039992},
  url = {https://dl.acm.org/doi/10.1145/1039991.1039992}
}

@article{10.1145/382109.382668,
  title = "{Scheme: The New Generation}",
  author = {Ramsdell, John D.},
  journal = {ACM SIGPLAN Lisp Pointers},
  volume = {VII},
  number = 4,
  pages = {13--14},
  year = 1994,
  month = oct,
  publisher = {Association for Computing Machinery},
  doi = {10.1145/382109.382668},
  url = {https://dl.acm.org/doi/10.1145/382109.382668},
}

@inproceedings{10.1145/277650.277719,
  title = "{Proper Tail Recursion and Space Efficiency}",
  author = "Clinger, William D.",
  booktitle = {Proceedings of the ACM SIGPLAN 1998 Conference on Programming Language Design and Implementation (PLDI '98)},
  pages = {174--185},
  year = 1998,
  month = may,
  publisher = {Association for Computing Machinery},
  doi = {10.1145/277650.277719},
  url = {https://dl.acm.org/doi/10.1145/277650.277719}
}


@article{10.1145/277652.277719,
  title = "{Proper Tail Recursion and Space Efficiency}",
  author = "Clinger, William D.",
  journal = {ACM SIGPLAN Notices},
  volume = 33,
  number = 5,
  pages = {174--185},
  year = 1998,
  month = may,
  publisher = {Association for Computing Machinery},
  doi = {10.1145/277652.277719},
  url = {https://dl.acm.org/doi/10.1145/277652.277719}
}

@article{10.1145/147135.147252,
  title = "{The Scheme of Things}",
  author = "Rees, Jonathan A.",
  journal = {ACM SIGPLAN Lisp Pointers},
  volume = {V},
  number = 3,
  pages = {39--46},
  year = 1992,
  month = aug,
  publisher = {Association for Computing Machinery},
  doi = {10.1145/147135.147252},
  url = {https://dl.acm.org/doi/10.1145/147135.147252}
}

@inproceedings{10.1145/141471.141545,
  title = "{Taming the Y Operator}",
  author = "Rozas, Guillermo Juan",
  booktitle = {Proceedings of the 1992 ACM Conference on LISP and Functional Programming (LFP '92)},
  pages = {226--234},
  year = 1992,
  month = jan,
  publisher = {Association for Computing Machinery},
  doi = {10.1145/141471.141545},
  url = {https://dl.acm.org/doi/10.1145/141471.141545}
}


@article{10.1145/141478.141545,
  title = "{Taming the Y Operator}",
  author = "Rozas, Guillermo Juan",
  journal = {ACM SIGPLAN Lisp Pointers},
  volume = {V},
  number = 1,
  pages = {226--234},
  year = 1992,
  month = jan,
  publisher = {Association for Computing Machinery},
  doi = {10.1145/141478.141545},
  url = {https://dl.acm.org/doi/10.1145/141478.141545}
}

@inproceedings{10.1145/154766.155373,
author = {Steele, Guy L. and Gabriel, Richard P.},
title = {The Evolution of Lisp},
year = {1993},
isbn = {0897915704},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/154766.155373},
doi = {10.1145/154766.155373},
abstract = {Lisp is the world's greatest programming language—or so its proponents think. The structure of Lisp makes it easy to extend the language or even to implement entirely new dialects without starting from scratch. Overall, the evolution of Lisp has been guided more by institutional rivalry, one-upsmanship, and the glee born of technical cleverness that is characteristic of the “hacker culture” than by sober assessments of technical requirements. Nevertheless this process has eventually produced both an industrial-strength programming language, messy but powerful, and a technically pure dialect, small but powerful, that is suitable for use by programming-language theoreticians.We pick up where McCarthy's paper in the first HOPL conference left off. We trace the development chronologically from the era of the PDP-6, through the heyday of Interlisp and MacLisp, past the ascension and decline of special purpose Lisp machines, to the present era of standardization activities. We then examine the technical evolution of a few representative language features, including both some notable successes and some notable failures, that illuminate design issues that distinguish Lisp from other programming languages. We also discuss the use of Lisp as a laboratory for designing other programming languages. We conclude with some reflections on the forces that have driven the evolution of Lisp.},
booktitle = {The Second ACM SIGPLAN Conference on History of Programming Languages},
pages = {231–270},
numpages = {40},
location = {Cambridge, Massachusetts, USA},
series = {HOPL-II}
}


@article{10.1145/155360.155373,
author = {Steele, Guy L. and Gabriel, Richard P.},
title = {The Evolution of Lisp},
year = {1993},
issue_date = {March 1993},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {28},
number = {3},
issn = {0362-1340},
url = {https://doi.org/10.1145/155360.155373},
doi = {10.1145/155360.155373},
abstract = {Lisp is the world's greatest programming language—or so its proponents think. The structure of Lisp makes it easy to extend the language or even to implement entirely new dialects without starting from scratch. Overall, the evolution of Lisp has been guided more by institutional rivalry, one-upsmanship, and the glee born of technical cleverness that is characteristic of the “hacker culture” than by sober assessments of technical requirements. Nevertheless this process has eventually produced both an industrial-strength programming language, messy but powerful, and a technically pure dialect, small but powerful, that is suitable for use by programming-language theoreticians.We pick up where McCarthy's paper in the first HOPL conference left off. We trace the development chronologically from the era of the PDP-6, through the heyday of Interlisp and MacLisp, past the ascension and decline of special purpose Lisp machines, to the present era of standardization activities. We then examine the technical evolution of a few representative language features, including both some notable successes and some notable failures, that illuminate design issues that distinguish Lisp from other programming languages. We also discuss the use of Lisp as a laboratory for designing other programming languages. We conclude with some reflections on the forces that have driven the evolution of Lisp.},
journal = {SIGPLAN Not.},
month = {mar},
pages = {231–270},
numpages = {40}
}

@inproceedings{10.1145/231379.231395,
author = {Bruggeman, Carl and Waddell, Oscar and Dybvig, R. Kent},
title = {Representing Control in the Presence of One-Shot Continuations},
year = {1996},
isbn = {0897917952},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/231379.231395},
doi = {10.1145/231379.231395},
abstract = {Traditional first-class continuation mechanisms allow a captured continuation to be invoked multiple times. Many continuations, however, are invoked only once. This paper introduces one-shot continuations, shows how they interact with traditional multi-shot continuations, and describes a stack-based implementation of control that handles both one-shot and multi-shot continuations. The implementation eliminates the copying overhead for one-shot continuations that is inherent in multi-shot continuations.},
booktitle = {Proceedings of the ACM SIGPLAN 1996 Conference on Programming Language Design and Implementation},
pages = {99–107},
numpages = {9},
location = {Philadelphia, Pennsylvania, USA},
series = {PLDI '96}
}


@article{10.1145/249069.231395,
author = {Bruggeman, Carl and Waddell, Oscar and Dybvig, R. Kent},
title = {Representing Control in the Presence of One-Shot Continuations},
year = {1996},
issue_date = {May 1996},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {31},
number = {5},
issn = {0362-1340},
url = {https://doi.org/10.1145/249069.231395},
doi = {10.1145/249069.231395},
abstract = {Traditional first-class continuation mechanisms allow a captured continuation to be invoked multiple times. Many continuations, however, are invoked only once. This paper introduces one-shot continuations, shows how they interact with traditional multi-shot continuations, and describes a stack-based implementation of control that handles both one-shot and multi-shot continuations. The implementation eliminates the copying overhead for one-shot continuations that is inherent in multi-shot continuations.},
journal = {SIGPLAN Not.},
month = {may},
pages = {99–107},
numpages = {9}
}

@inproceedings{10.1145/182409.156784,
author = {Ashley, J. Michael and Dybvig, R. Kent},
title = {An Efficient Implementation of Multiple Return Values in Scheme},
year = {1994},
isbn = {0897916433},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/182409.156784},
doi = {10.1145/182409.156784},
abstract = {This paper describes an implementation of the new Scheme multiple values interface. The implementation handles multiple values efficiently, with no run-time overhead for normal calls and returns. Error checks are performed where necessary to insure that the expected number of values is returned in all situations. The implementation fits cleanly with our direct-style compiler and stack-based representation of control, but is equally well suited to continuation-passing style compilers and to heap-based run-time architectures.},
booktitle = {Proceedings of the 1994 ACM Conference on LISP and Functional Programming},
pages = {140–149},
numpages = {10},
location = {Orlando, Florida, USA},
series = {LFP '94}
}


@article{10.1145/182590.156784,
author = {Ashley, J. Michael and Dybvig, R. Kent},
title = {An Efficient Implementation of Multiple Return Values in Scheme},
year = {1994},
issue_date = {July-Sept. 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {VII},
number = {3},
issn = {1045-3563},
url = {https://doi.org/10.1145/182590.156784},
doi = {10.1145/182590.156784},
abstract = {This paper describes an implementation of the new Scheme multiple values interface. The implementation handles multiple values efficiently, with no run-time overhead for normal calls and returns. Error checks are performed where necessary to insure that the expected number of values is returned in all situations. The implementation fits cleanly with our direct-style compiler and stack-based representation of control, but is equally well suited to continuation-passing style compilers and to heap-based run-time architectures.},
journal = {SIGPLAN Lisp Pointers},
month = {jul},
pages = {140–149},
numpages = {10}
}

@inproceedings{10.1145/800068.802142,
author = {Rees, Jonathan A. and Adams IV, Norman I.},
title = {T: A Dialect of Lisp or LAMBDA: The Ultimate Software Tool},
year = {1982},
isbn = {0897910826},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/800068.802142},
doi = {10.1145/800068.802142},
abstract = {The T project is an experiment in language design and implementation. Its purpose is to test the thesis developed by Steele and Sussman in their series of papers about the Scheme language: that Scheme may be used as the basis for a practical programming language of exceptional expressive power; and, that implementations of Scheme could perform better than other Lisp systems, and competitively with implementations of programming languages, such as C and Bliss, which are usually considered to be inherently more efficient than Lisp on conventional machine architectures. We are developing a portable implementation of T, currently targeted for the VAX under the Unix and VMS operating systems and for the Apollo, a MC68000-based workstation.},
booktitle = {Proceedings of the 1982 ACM Symposium on LISP and Functional Programming},
pages = {114–122},
numpages = {9},
location = {Pittsburgh, Pennsylvania, USA},
series = {LFP '82}
}

@article{10.1145/382109.382669,
author = {Anglade, S. and Lacrampe, J. J. and Queinnec, C.},
title = {Semantics of Combinations in Scheme},
year = {1994},
issue_date = {Oct. 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {VII},
number = {4},
issn = {1045-3563},
url = {https://doi.org/10.1145/382109.382669},
doi = {10.1145/382109.382669},
abstract = {This paper presents a denotational semantics for the combinations of the Scheme language. Scheme leaves unspecified the order of evaluation of the terms of a combination. Our purpose is to formally and denotationally characterize such indeterminacy. We achieve this by extending the denotation as well as the domain of final answers to take into account the various possible orders of evaluation.},
journal = {SIGPLAN Lisp Pointers},
month = {oct},
pages = {15–20},
numpages = {6}
}

@article{10.1145/181889.181891,
author = {Queinnec, Christian},
title = {A Library of High Level Control Operators},
year = {1993},
issue_date = {Oct.-Dec. 1993},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {VI},
number = {4},
issn = {1045-3563},
url = {https://doi.org/10.1145/181889.181891},
doi = {10.1145/181889.181891},
abstract = {Numerous high-level control operators, with various properties, exist in the literature. To understand or compare them is difficult since their definitions use quite different theoretical frameworks; moreover, to our knowledge, no implementation offers them all. This paper tries to explain control operators by the often simple stack manipulation they perform. We therefore present what we think these operators are, in an executable framework derived from abstract continuations. This library is published in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. For instance, we do not claim our implementation to be faithful nor we attempt to formally derive these implementations from their original definitions. The goal is to give a flavor of what control operators are, from an implementation point of view. Last but worth to say, all errors are mine.},
journal = {SIGPLAN Lisp Pointers},
month = {oct},
pages = {11–26},
numpages = {16}
}

@inproceedings{10.1145/41625.41634,
author = {Gelernter, D. and Jagannathan, S. and London, T.},
title = {Environments as First Class Objects},
year = {1987},
isbn = {0897912152},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/41625.41634},
doi = {10.1145/41625.41634},
abstract = {We describe a programming language called Symmetric Lisp that treats environments as first-class objects. Symmetric Lisp allows programmers to write expressions that evaluate to environments, and to create and denote variables and constants of type environment as well. One consequence is that the roles filled in other languages by a variety of limited, special purpose environment forms like records, structures, closures, modules, classes and abstract data types are filled instead by a single versatile and powerful structure. In addition to being its fundamental structuring tool, environments also serve as the basic functional object in the language. Because the elements of an environment are evaluated in parallel, Symmetric Lisp is a parallel programming language; because they may be assembled dynamically as well as statically, Symmetric Lisp accommodates an unusually flexible and simple (parallel) interpreter as well as other history-sensitive applications requiring dynamic environments. We show that first-class environments bring about fundamental changes in a language's structure: conventional distinctions between declarations and expressions, data structures and program structures, passive modules and active processes disappear.},
booktitle = {Proceedings of the 14th ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages},
pages = {98–110},
numpages = {13},
location = {Munich, West Germany},
series = {POPL '87}
}

@article{Hieb1994Subcontinuations,
	author = {Hieb, Robert and Dybvig, R. Kent and Anderson, III, Claude W.},
	journaltitle = {LISP and Symbolic Computation},
	shortjournal = {LISP and Symbolic Computation},
	doi = {10.1007/bf01019946},
	issn = {0892-4635},
	number = {1},
	date = {1994-01},
	language = {en},
	pages = {83--109},
	publisher = {{Springer Science and Business Media LLC}},
	title = {Subcontinuations},
	url = {http://dx.doi.org/10.1007/BF01019946},
	volume = {7},
}

@article{Dybvig1990new,
	author = {Dybvig, R. Kent and Hieb, Robert},
	journaltitle = {Lisp and Symbolic Computation},
	shortjournal = {Lisp and Symbolic Computation},
	doi = {10.1007/bf01806099},
	issn = {0892-4635},
	number = {3},
	date = {1990-09},
	language = {en},
	pages = {229--244},
	publisher = {{Springer Science and Business Media LLC}},
	title = {A new approach to procedures with variable arity},
	url = {http://dx.doi.org/10.1007/BF01806099},
	volume = {3},
}

@article{Moreau1998,
	author = {Moreau, Luc},
	journaltitle = {Higher Order Symbolic Computation},
	doi = {10.1023/a:1010087314987},
	issn = {1388-3690},
	number = {3},
	date = {1998},
	pages = {233--279},
	publisher = {{Springer Science and Business Media LLC}},
	url = {http://dx.doi.org/10.1023/A:1010087314987},
	volume = {11},
}

